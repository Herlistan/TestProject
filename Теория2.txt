1 Урок. 19.09
Гит.
Гит имеет историю действий. Что позволяет в конце работы (финализация работы) всё объединить.
Или же замеждить файлы. Отличное решение для работы в команде. Также есть Commit, это точка сохранения.
С0 - С1 - С2
   \
     - С3
Здесь С1 хранит изменения над файлом С0. Изменения С2 хранит относительно С1. В них хранится изменения 
и (к)ХЭШ. Каждый коммит имеет свой уникальный номер, что хранится в ХЭШ. 
Mesh - это объединение 2-ух коммитов. Могут быть кофликты. Напрмер, в одном из коммитов были 
задействованы файлы одинаковые, но использование их разное. 
Гит безотказный. Создаем репозиторий. Это область, что хранит информацию о проекте.
 rep - С0 - С1 - С2
      \
        - С3
Все изменения архивируется, оптимизируется и т.п. хранится в репозитории. Есть облако, что позволит
откатить всё, даже при удалении или потери репозитория.

 rep - С0 - С1 - С2
   |   \
   |    - С3
   |
Cloud

Будем писать код на Визуалке.
SSH ссылка нужна для ?ключей?.
Remotes в Fork - это облако. Туда кидаем всё и дома я могу скачать. 
Pull - изменения из облака накатит на локальные на пк. 
Push - коммиты С4 идут в облако из локалки.

Скачать данные дома.
____________________________________________________________________________________________________________________________________________________________________________

Лекция 2

 Resources
    |
[lession1] -> [lession2] - > ... -> [lession7] .... [n] -> [lession36] - > Project is ready
    |  -> result                             \
    Technology                                [Personal project]

Можно попросить любого преподавателя раскрыть любую тему. 
Двойной клик на коммит, тем самым можно создать новую ветку и от нее развивать тему.

Тема: память. Важно!!!
В любом ЯП управляют памятью. С++ память управляется программистом, а в С# всё упростили, он высокоуровневый. 
Шарп имеет два блока памяти 1 стек и 2 куча. Стек маленький ящик, а куча большая. Стек очень быстрая память в которой внутри всё упорядочено, форматируется быстро. 
Она является процессорной памятью, а куча оперативная. В стек мы не лезем, так всё ок. А куча нет, там много релокаций. Мы написали переменные и забыли о них, а они висят.
В Шарпе есть провекрка, есть ли ссылка на эту ячейку. Что этот процесс является очень ресурсоёмким. Из-за этого игра висла. 
Решение - меньше лоцировать. Как меньше приходить к куче. 
Лоцировать - определять (определить) местоположение какого-либо объекта с помощью специальных устройств, органов.

short s = 0;
int i = 0;
long l = 0;
float f =0;
double d = 0;

Хранятся в стеке. Т.е. всё ок.

object n = d; - операция боксинга.

Оно хранится в куче. Т.к. обдект является самым базовым элементом и является ссылочным.
Ссылочный тип можно передать как параметр. 
Ссылочные хрантятся в куча, а не ссылочные в стеке.

double d2 = (double)n;

Это анбоксиннг. Ничего нет такого в этом, но это релокация. В мобилке очень критично может быть. 

long l2 = short.MaxValue;
Тут лонг урежится до шорта.

Тема 2. Методы. 

public void TestFunc(int i)
{
    i = 10;
    Debug.Log(i);
}

public void TestFunc2(in int i)
{
    i = 10;
    Debug.Log(i);
}

in делает i в ссылочный тип. Но без бокс и анбокса. Но это будет безопаснее, чем делать боксинг и анбоксинг.

public void TestFunc3(out int i)
{
    i = 10;
    Debug.Log(i);
}

Здесь важно присовить значение i. 

Переменные хранятся в памяти. Мало того, что Object находится в куча, там ещё и в стеке. Мои основные данные хранятся в куче. Все переменные типа struct хранятся в стеке, а находятся в куче.

int i3;
Myclass mc = new Myclass();

New говорит, что надо выделить новую ячейку в памяти. 

Myclass mc = new Myclass();
TestFunc3(mc);

public void TestFunc3(Myclass mc)
{
    
}

Сам класс и ее переменные попадают в кучу. 
Ещё вызовы друг друга вызывают перегруз. Новая переменная - куча. Всё идет в кучу. 
В классе ничего нет. Мы просто передали ее в класс, сделали ее ссылочной и можно с ней делать что угодно. 
Myclass mc = new Myclass();
TestFunc3(out mc);

public void TestFunc3(out Myclass mc)
{
    
}

Добивив аут, переменная создает её копию. Лучше ссылочными типа не пользоваться. 

VAR. Это тот тип данных, что сам определяет данные. Он неопределнный. С# создавался, что ни о чем не думать, ни о памяти, типы данных. Ксти, у C# пробемы с памятью из-за этого. 
Каждый класс должен быть назван только односложно, только одну функцию выполнять. 

Класс - это набор данных. И класс хранит строку, число. Если передать значение в функцию, то просто ссылка отправится к ссылке не заняв ячейки памяти.  
Если mc перезаписать на mc2, то создаться грубо говоря mc3, а mc удалится изанчальный. И содатся новая ячейка.

Когда использовать ссылочный тип. 
Пока ею пользуются, она живет и находится в куче. Стукутра используется для атомарных переменных, вектор 1,2,3, индексы. Что-то маленькое. Ибо стурктура часто передается, нужна безопаснсоть.

Область видимости.
{} - мы стартовали в область видимости. 
Есть в {} создать ещё одну, то это отдельная обалсть видимости. (if. else, for). Если в if создана i2, то за этой обасти видимости, не будет доступна i2. 
После области видимости i2 будет полностью уничтожена. Но это не касается классов и структур и ссылочные в целом (объявить её public).

for(int i = 0...)
for(int i = 0...)
они не конфликтуют. Ибо у них своя область видимости.

Массивы.

int[] array = new int[3]. Создалось 3 инта! Т.е. 3 ячейки памяти занялось. Массив хорош тем, что он быстр по перемещению. Его данные хранятся в одной плоскости. В одной последовательнсоти. 
Т.к. это ссылочный тип он хранится в куче. Ещё он выделяет весь кусок памяти и работает с ним. есл будет не хватать, то не зарабоатет. Их можно перебирать. Все игры аппелируют с даннными.
Данные игрока, их параметров...
Если правильно упорядочить данные, то и само приложение будет быстрее работать. 
!!!Использовать стек и массивы.!!! Самый топ. Этим можно 1 млн игроков на сервере и чтобы всё ломалось, взрывалось.

Если создавали object[] array = new object[3]. Тут выйдет что инт будет хравиться в куче, инт - который нумерация объектов. А сами объекты, т.е. их тип, разбросан в куче.
Стараться создавать коллекции 
строго типизированные.
Массив хорош ием, что он лежит в большой ячейке, легко и быстро читать. Друг за другом. А объект, сначала его инт - номер, потом поиск пути к самому объекту. 

List<int> List = new List<int>(); Это динамический массив. Он создал массив из четырех данных. Если доьавить новый элемент, т он удалить массив на 4 и создаст сразу на 8...16...32 туда где есть свободное место.
Пока живет лист, то и живет сам массив.

ДЗ\ Написать свой лист. 
Наш лист имеет в себе массив из 4-ех чисел. Нужен пример где будет создан лист и операции. Пуш (0-10), потом удалить что-то. И вывесли того. Что сот алсось в листе. 
public class MyList
{
	private int[] m_array = new int[4]
	public int count {get; }
	public void Push(int i)
	{ 

	}
	public int Insert(int item)
	{
	}

	public int IndexOF(int item)
	{
		return 0;
	}
	public int Remove(int item)
	{
	
	}
	public int RemoveAt(int item)
	{
		
	}
	public int Clear(int item)
	{
	
	}
}




































